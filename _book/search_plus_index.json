{"./":{"url":"./","title":"Typescript 简介","keywords":"","body":"TypeScript 简介 TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码，可以运行在任何浏览器上。TypeScript添加了可选的静态类型系统、很多尚未正式发布的ECMAScript新特性（如装饰器 [1] ）支持 ECMAScript 6 标准。2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版TypeScript。 JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 语言特性 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 以下功能是从 ECMA 2015 反向移植而来： 类 模块 lambda 函数的箭头语法 可选参数以及默认参数 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:58 "},"Tutorials/TypeScript-in-5-minutes.html":{"url":"Tutorials/TypeScript-in-5-minutes.html","title":"5分钟上手","keywords":"","body":"5分钟上手Typescript 让我们使用TypeScript来创建一个简单的Web应用。 1. 安装 npm install -g typescript 2. 构建你的第一个TypeScript文件 在编辑器，将下面的代码输入到greeter.ts文件 function greeter(person) { return \"Hello, \" + person; } let user = \"Jane User\"; console.log(greeter(user)) 然后在当前目录下运行 ts文件 tsc greeter.ts 执行命令之后会创建一个转义成ES5的greeter.js文件，它包含了和输入文件中相同的JavsScript代码。 接下来让我们看看TypeScript工具带来的高级功能。 给 person函数的参数添加: string类型注解，如下： function greeter(person: string) { return \"Hello, \" + person; } let user = \"Jane User\"; console.log(greeter(user)) 3. 类型注解 TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter函数接收一个字符串参数。 然后尝试把 greeter的调用改成传入一个数组： function greeter(person: string) { return \"Hello, \" + person; } let user = [0, 1, 2]; console.log(greeter(user)) 重新编译，你会看到产生了一个错误。 greeter.ts(6,21): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 类似地，尝试删除greeter调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 4. 接口 让我们开发这个示例应用。这里我们使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。 interface Person { firstName: string; lastName: string; } function greeter(person: Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = { firstName: \"Jane\", lastName: \"User\" }; console.log(greeter(user)) 5. 类 最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。 让我们创建一个Student类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。 还要注意的是，在构造函数的参数上使用public等同于创建了同名的成员变量。 class Student { fullName: string; constructor(public firstName, public middleInitial, public lastName) { this.fullName = firstName + \" \" + middleInitial + \" \" + lastName; } } interface Person { firstName: string; lastName: string; } function greeter(person : Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = new Student(\"Jane\", \"M.\", \"User\"); console.log(greeter(user)) 重新运行tsc greeter.ts，你会看到生成的JavaScript代码和原先的一样。 TypeScript里的类只是JavaScript里常用的基于原型面向对象编程的简写。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Tutorials/Migrating-from-Javascript.html":{"url":"Tutorials/Migrating-from-Javascript.html","title":"从JavaScript迁移","keywords":"","body":"JavaScript 迁移 TypeScript不是存在于真空中。 它从JavaScript生态系统和大量现存的JavaScript而来。 将JavaScript代码转换成TypeScript虽乏味却不是难事。 接下来这篇教程将教你怎么做。 在开始转换TypeScript之前，我们假设你已经理解了足够多本手册里的内容。 1. 设置目录 如果你在写纯JavaScript，你大概是想直接运行这些JavaScript文件， 这些文件存在于 src，lib或dist目录里，它们可以按照预想运行。 若如此，那么你写的纯JavaScript文件将做为TypeScript的输入，你将要运行的是TypeScript的输出。 在从JS到TS的转换过程中，我们会分离输入文件以防TypeScript覆盖它们。 你也可以指定输出目录。 你可能还需要对JavaScript做一些中间处理，比如合并或经过Babel再次编译。 在这种情况下，我们假设你已经设置了这样的目录结构： projectRoot ├── src │ ├── file1.js │ └── file2.js ├── built └── tsconfig.json 如果你在src目录外还有tests文件夹，那么在src里可以有一个tsconfig.json文件，在tests里还可以有一个。 2. 编辑配置文件 TypeScript使用tsconfig.json文件管理工程配置，例如你想包含哪些文件和进行哪些检查。 让我们先创建一个简单的工程配置文件： { \"compilerOptions\": { \"outDir\": \"./built\", \"allowJs\": true, \"target\": \"es5\" }, \"include\": [ \"./src/**/*\" ] } 这里我们为TypeScript设置了一些东西: 读取所有可识别的src目录下的文件（通过include）。 接受JavaScript做为输入（通过allowJs）。 生成的所有文件放在built目录下（通过outDir）。 将JavaScript代码降级到低版本比如ECMAScript 5（通过target）。 现在，如果你在工程根目录下运行tsc，就可以在built目录下看到生成的文件。 built下的文件应该与src下的文件相同。 现在你的工程里的TypeScript已经可以工作了。 早期收益 现在你已经可以看到TypeScript带来的好处，它能帮助我们理解当前工程。 如果你打开像 VS Code或Visual Studio这样的编译器，你就能使用像自动补全这样的工具。 你还可以配置如下的选项来帮助查找BUG： noImplicitReturns 会防止你忘记在函数末尾返回值。 noFallthroughCasesInSwitch 会防止在switch代码块里的两个case之间忘记添加break语句。 TypeScript还能发现那些执行不到的代码和标签，你可以通过设置allowUnreachableCode和allowUnusedLabels选项来禁用。 3. 与构建工具进行集成 在你的构建管道中可能包含多个步骤。 比如为每个文件添加一些内容。 每种工具的使用方法都是不同的，我们会尽可能的包涵主流的工具。 1） Gulp 如果你在使用时髦的Gulp，我们已经有一篇关于使用Gulp结合TypeScript并与常见构建工具Browserify，Babelify和Uglify进行集成的教程。 请阅读这篇教程。 2）Webpack Webpack集成非常简单。 你可以使用 ts-loader，它是一个TypeScript的加载器，结合source-map-loader方便调试。 运行： $ npm install ts-loader source-map-loader -D 并将下面的选项合并到你的webpack.config.js文件里： module.exports = { entry: \"./src/index.ts\", output: { filename: \"./dist/bundle.js\", }, // Enable sourcemaps for debugging webpack's output. devtool: \"source-map\", resolve: { // Add '.ts' and '.tsx' as resolvable extensions. extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"] }, module: { loaders: [ // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'. { test: /\\.tsx?$/, loader: \"ts-loader\" } ], preLoaders: [ // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'. { test: /\\.js$/, loader: \"source-map-loader\" } ] }, // Other options... }; 要注意的是ts-loader必须在其它处理.js文件的加载器之前运行。 4. 转换到TypeScript文件 到目前为止，你已经做好了使用TypeScript文件的准备。 第一步，将 .js文件重命名为.ts文件。 如果你使用了JSX，则重命名为 .tsx文件。 如果你不想让TypeScript将没有明确指定的类型默默地推断为 any类型，可以在修改文件之前启用noImplicitAny。 你可能会觉得这有些过度严格，但是长期收益很快就能显现出来。 在转换后将会看到错误信息。 重要的是我们要逐一的查看它们并决定如何处理。 通常这些都是真正的BUG，但有时必须要告诉TypeScript你要做的是什么。 1）由模块导入 你可能会看到一些类似Cannot find name 'require'.和Cannot find name 'define'.的错误。 遇到这种情况说明你在使用模块。 你仅需要告诉TypeScript它们是存在的： // For Node/CommonJS declare function require(path: string): any; 或者 // For RequireJS//AMD declare function define(...args: any[]): any; 最好是避免使用这些调用而改用TypeScript的导入语法 首先，你要使用TypeScript的module标记来启用一些模块系统，可用的选项有commonjs, amd, system,umd。 例如： var foo = require('foo') foo.doStuff(); 用TS语法改写 import foo = require('foo') foo.doSuff() 2）获取声明文件 js 转换成 ts 可能会遇到 cannot find module 'foo' 这样的错误，问题出在没有声明文件来描述你的代码库，幸运的是这非常简单，如果TS抱怨像是没有lodash包，那你只需要安装声明文件就可以 npm install -s @types/lodash 如果你没有使用 commonjs模块选项，那么就需要讲moduleResolution选项设置为node 之后，你就可以导入lodash了，并且会获得精确的自动补全功能。 3）由模块导出 通常来说，模块导出涉及到exports 或者 module.exports。TS 允许你是用顶级的导出语句，比如： 导出匿名函数 module.exports.feedPets = function(pets){ //... } TS改写： export function(pets){ // ... } 导出函数名: function foo(){ // ... } TS 改写： function foo(){ // ... } export = foo 4）过多或过少的参数 有时你会发现你在调用一个具有过多或者过少参数的函数。通常，这是一个BUG，单在某些情况下，你可以声明一个使用arguments对象而不需要写出所有的参数 function myCoolFunction() { if (arguments.length == 2 && !Array.isArray(arguments[1])) { var f = arguments[0]; var arr = arguments[1]; // ... } // ... } myCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]); myCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4); 这种情况下，我们需要利用TypeScript的函数重载来告诉调用者 myCoolFunction函数的调用方式。 function myCoolFunction(f: (x: number)=> void, nums: number[]): void; function myCoolFunction(f: (x: number)=> void, ...nums: number[]): void; function myCoolFunction() { if(arguments.length == 2 && !Array.isArray(arguments[1])){ var f = arguments[0] var arr = arguments[1] // ... } // ... } 我们为 myCoolFunction 函数添加了两个重载签名。第一个检查myCoolFunction函数是否接受一个函数（它又接受一个number参数）和一个number数组。第二个同样接收了一个函数，并且剩余参数（...nums）来表示之后的其他所有参数必须是number类型 5）连续添加属性 有些人可能因为代码美观性而喜欢先创建一个对象然后立即添加属性 var option = {} option.color = 'red'; option.volum = 11 TS会提示你不能给color和volum赋值，因为先前指定option的类型为{}并不带有任何属性。如果你将声明变成对象字面量将不会产生错误。 var option = { color: 'red', volum : 11 } 你还可以定义option的类型并且添加类型断言到对象字面量上 interface Option {color: string, volum: number} let option = {} as Option option.color = 'red' option.volum = 11 你也可以把option指定成any类型，这是最简单的，也是受益最少的 any,Object,{}区别 any是最普通的类型但是允许你在上面做任何事情，也就是你可以在上面调用，构造，访问他的属性等等。但是当你使用any时，也就意味着你将失去大多数 TS 听歌的错误检查和编译器支持。 如果你还是决定使用Object和{}，虽说他们基本一样，但是从技术层面说，{}在一些深奥的情况里比Object更普通 6）启用严格检查 TypeScript提供了一些检查来保证安全以及帮助分析你的程序。 当你将代码转换为了TypeScript后，你可以启用这些检查来帮助你获得高度安全性。 （1）没有隐式的any 在某些情况下TypeScript没法确定某些值的类型。 那么TypeScript会使用 any类型代替。 这对代码转换来讲是不错，但是使用 any意味着失去了类型安全保障，并且你得不到工具的支持。 你可以使用 noImplicitAny选项，让TypeScript标记出发生这种情况的地方，并给出一个错误。 （2）严格的 null 和 undefined 替换 默认地，TypeScript把null和undefined当做属于任何类型。 这就是说，声明为 number类型的值可以为null和undefined。 因为在JavaScript和TypeScript里， null和undefined经常会导致BUG的产生，所以TypeScript包含了strictNullChecks选项来帮助我们减少对这种情况的担忧。 当启用了strictNullChecks，null和undefined获得了它们自己各自的类型null和undefined。 当任何值 可能为null，你可以使用联合类型。 比如，某值可能为 number或null，你可以声明它的类型为number | null。 假设有一个值TypeScript认为可以为null或undefined，但是你更清楚它的类型，你可以使用!后缀。 declare var foo: string[] | null; foo.length; // error - 'foo' is possibly 'null' foo!.length; // okay - 'foo!' just has type 'string[]' 要当心，当你使用strictNullChecks，你的依赖也需要相应地启用strictNullChecks。 （3）this 没有隐式的 any 当你在类的外部使用this关键字时，它会默认获得any类型。 比如，假设有一个 Point类，并且我们要添加一个函数做为它的方法： class Point { constructor(public x, public y){ } getDistance(p: Point){ let dx = p.x - this.x; let dy = p.y - this.y; return Msth.sqrt(dx**2 + dy**2) } } // ... // 重开断言 interface Point { distanceFromOrigin(point: Point): number; } Point.prototype.distanceFromOrigin = function(point: Point){ return this.getDistance({x: 0, y: 0}) } 这就产生了我们上面提到的错误 - 如果我们错误地拼写了getDistance并不会得到一个错误。 正因此，TypeScript有 noImplicitThis选项。 当设置了它，TypeScript会产生一个错误当没有明确指定类型（或通过类型推断）的 this被使用时。 解决的方法是在接口或函数上使用指定了类型的 this参数： 下面是原型链改写 Point.prototype.distanceFromOrigin = function(this: Point, point: Point){ return this.getDistance({x: 0, y: 0}); } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-11 21:29 "},"HandBook/Basic-Types.html":{"url":"HandBook/Basic-Types.html","title":"基础类型","keywords":"","body":"基础类型 1. 布尔值 boolean，可以定义为true/false let isDone: boolean = false 2. 数值 number，所有的数字都是浮点数，支持十进制，十六进制，二进制和八进制 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 3. 字符串 string，可以使用双引号（\"\"）、单引号（''）和反引号（`` ）表示 let name: string = 'bob'; let sex: string = \"male\"; let sentence: string = `hello, my name is ${name}`; 4. 数组 有两种方法可以定义数组 在元素类型后面接上[]，表示由此类型元素组成一个数组 let list: number[] = [1, 2, 3]; 使用数组泛型，Array let list: Array = [1, 2, 3]; 5. 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同，比如你可以定义一对值分别为string和number类型的元组 let x: [string, number]; x = ['hello', 10]; // ok x = [10, 'hello']; // error 当访问一个一直索引的元素，会得到正确的类型 console.log(x[0].substr(1)); // ello console.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个跨界的元素，会使用联合类型替代 x[3] = 'world';// OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 6. 枚举 enum类型是对JavaScript标准数据类型的一个补充 enum Color {Red, Green, Yellow} let c: Color = Color.Green 默认情况下，从0开始为元素编号，你也可以手动指定成员的数值。例如，我们将上面的例子改成从1开始编号： enum Color {Red=1, Green, Yellow} let c: Color = Color.Green 也可以全部手动赋值 enum Color {Red=1, Green=2, Yellow=4} let colorName: string = Color[2] console.log(colorName) // 显示'Green'因为上面代码里它的值是2 7. Any any，有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来子推燕动态的内容，比如用户输入或者第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让他们通过编译阶段的检查，那我们就可使用any类型来标记这些变量： let notSure: any = 4; notSure = 'hello'; notSure = true; 在对现有代码进行改写的时候，any类型是十分有用的。他允许你在变异时可选择地包含或移除类型检查。你可能认为Object有相似的作用，就想他在其他语言中的那样。但是Object类型的变量只是允许你给他赋任意值，但是却不能够在他上面调用任何方法，几遍他真的有这些方法： let notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object' 当你只知道一部分数据类型时，any类型也是有用的。比如，你有一个数组，他包含了不同的类型的数据： let list: any[] = [1, 'hello', true]; list[1] = 100; 8. Void void，某种程度上来说void类型和any类型相反，他标书没有任何类型。当一个函数没有返回之时，你通常会见到其返回值类型为void： function warnUser(): void{ console.log('This is my warning message'); } 声明一个void类型的变量没有什么大用，因为你指能赋予它undefined和null let unusable: void = undefined; 9. Null 和 Undefined null的类型就是null undefined的类型就是undefined 和void相似，他们本身的类型用处不是很大： // 我们不能给这些变量赋太多的值 let u: undefined = undefined; let n: null = null; 默认情况下，null和undefined是所有类型的子类型，也就是说你可以把null和undefined赋值给number类型的变量 然而，当你制定了--strictNullChecks标记时，null和undefined只能赋值给void和他们各自。这能避免很多常见的问题，允许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。 注意： 我们应该尽可能的使用 --strictNullChecks 10. Never never类型表示哪些用不存在值得类型，例如：never类型是那些总会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是never类型，当他们被用不为真的类型保护所约束时。 never类型是任意类型的子类型，也可以赋值给任意类型；然而，没有类型是never的子类型或可以赋值给never类型，（除了never本身之外）。即使any也不可以赋值给never。 下面是一些返回never类型的函数： // 返回 never类型的函数必须存在无法达到的终点，抛出异常 function error(message: string): never{ throw new Error(message); } // 推断类型的返回值类型为never, 返回一个错误 function fail(){ return error('something failed'); } // 返回never函数必须存在无法到达的终点 function infiniteLoop(): never { while (true){ // ... } } 11. Object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的 API，例如： declare function create(o: object | null): void; create({prop: 0}); // ok create(null); // ok create(42); // Error create('string'); // Error create(false); // Error create(undefined); // Error 12. 类型断言 有些时候，你会比TypeScript更了解某个值的详细信息，通常这会发生在你清楚地知道一个实体具有比他现有类型更确切的类型。 通过类型断言这种方式告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言中的类型转换，但是不进行特殊的数据检查和结构。他没有运行时的影响，只在编译阶段起作用， TypeScript 会假设你已经进行了必须的检查。 类型断言有两种形式： “尖括号”语法： let someValue: any = 'this is a string'; let strLength: number = (someValue).length; as语法 let someValue: any = 'this is a string'; let strLength: number = (someValue as string).length 两种形式是等价的。至于使用哪种写法全凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 23:52 "},"HandBook/Variable-Declarations.html":{"url":"HandBook/Variable-Declarations.html","title":"变量声明","keywords":"","body":"变量声明 1. var 一直以来我们都是通过var关键字定义JavaScript变量： var num = 10; 我们也可以在函数内部定义变量： function f() { var message = \"Hello, world!\"; return message; } 并且我们也可以在其它函数内部访问相同的变量。 function f() { var a = 10; return function g() { var b = a + 1; return b; } } var g = f(); g(); // returns 11; 上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。 function f() { var a = 1; a = 2; var b = g(); a = 3; return b; function g() { return a; } } f(); // returns 2 作用域规则 对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子： function f(shouldInitialize: boolean) { if (shouldInitialize) { var x = 10; } return x; } f(true); // returns '10' f(false); // returns 'undefined' 变量 x是定义在if语句里面，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 var作用域或函数作用域。 函数参数也使用函数作用域。 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错： function sumMatrix(matrix: number[][]) { var sum = 0; for (var i = 0; i 这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。 捕获变量怪异之处 快速的猜一下下面的代码会返回什么： for (var i = 0; i 介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。 运行结果： 10 10 10 10 10 很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样： 0 1 2 3 4 我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为5。 所以当函数被调用的时候，它会打印出 5！ 一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值： for (var i = 0; i 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。 2. let let与var的写法一致。 let hello = \"Hello!\"; 块作用域 当用let声明一个变量，它使用的是词法作用域或块作用域。 块作用域变量在包含它们的块或for循环之外是不能访问的。 function f(input: boolean) { let a = 100; if (input) { // Still okay to reference 'a' let b = a + 1; return b; } // Error: 'b' doesn't exist here return b; } 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。 在catch语句里声明的变量也具有同样的作用域规则。 try { throw \"oh no!\"; } catch (e) { console.log(\"Oh well.\"); } // Error: 'e' doesn't exist here console.log(e); 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。 a++; // illegal to use 'a' before it's declared; let a; 重定义和屏蔽 我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。 function f(x) { var x; var x; if (true) { var x; } } let声明就不会这么宽松: let x = 10; let x = 20; // 错误，不能在1个作用域里多次声明`x` 同样let声明和var声明，以及参数名重复时，也会给出错误 function f(x) { let x = 100; // error: interferes with parameter declaration } function g() { let x = 100; var x = 100; // error: can't have both declarations of 'x' } 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。 function sumMatrix(matrix: number[][]) { let sum = 0; for (let i = 0; i 这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它。 块级作用域变量的获取 用var声明的变量时，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。 function theCityThatAlwaysSleeps() { let getCity; if (true) { let city = \"Seattle\"; getCity = function() { return city; } } return getCity(); } 因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。 for (let i = 0; i 会输出与预料一致的结果： 0 1 2 3 4 3. const const 声明是声明变量的另一种方式。 const numLivesForCat = 9; 它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。 这很好理解，它们引用的值是不可变的。 const numLivesForCat = 9; const kitty = { name: \"Aurora\", numLives: numLivesForCat, } // Error kitty = { name: \"Danielle\", numLives: numLivesForCat }; // all \"okay\" kitty.name = \"Rory\"; kitty.name = \"Kitty\"; kitty.name = \"Cat\"; kitty.numLives--; 除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 4. let VS const 使用最小特权原则，所有变量除了你计划去修改的都应该使用const，使用 const也可以让我们更容易的推测数据的流动。 5. 解构 解构数组 最简单的解构莫过于数组的解构赋值了： let input = [1, 2]; let [first, second] = input; console.log(first); // 1 console.log(second); // 2 解构作用于已声明的变量会更好： // 交换变量 [first, second] = [second, first]; 作用于函数参数： function f([first, second]: [number, number]) { console.log(first); console.log(second); } f(input); 你可以在数组里使用...语法创建剩余变量： let [first, ...rest] = [1, 2, 3, 4]; console.log(first); // 1 console.log(rest); // [ 2, 3, 4 ] 当然，由于是JavaScript, 你可以忽略你不关心的尾随元素： let [first] = [1, 2, 3, 4]; console.log(first); // 1 或其它元素： let [, second, , fourth] = [1, 2, 3, 4]; 结构对象 let o = { a: \"foo\", b: 12, c: \"bar\" }; let { a, b } = o; 这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。 就像数组解构，你可以用没有声明的赋值： ({ a, b } = { a: \"baz\", b: 101 }); a // \"baz\" b // 101 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 你可以在对象里使用...语法创建剩余变量： let { a, ...passthrough } = o; let total = passthrough.b + passthrough.c.length; total // 15 属性重命名 你也可以给属性以不同的名字： let { a: newName1, b: newName2 } = o; 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。 let {a, b}: {a: string, b: number} = o; 默认值 默认值可以让你在属性为 undefined 时使用缺省值： function keepWholeObject(wholeObject: { a: string, b?: number }) { let { a, b = 1001 } = wholeObject; } 现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。 函数声明 解构也能用于函数声明。 看以下简单的情况： type C = { a: string, b?: number } function f({ a, b }: C): void { // ... } 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。 function f({ a=\"\", b=0 } = {}): void { // ... } f(); 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性： function f({ a, b = 0 } = { a: \"\" }): void { // ... } f({ a: \"yes\" }); // ok, default b = 0 f(); // ok, default to {a: \"\"}, which then defaults b = 0 f({}); // error, 参数'a' 是必须赋值的 展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如： let first = [1, 2]; let second = [3, 4]; let bothPlus = [0, ...first, ...second, 5]; console.log(bothPlus) // [0, 1, 2, 3, 4, 5] 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。 还可以展开对象： let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" }; let search = { ...defaults, food: \"rich\" }; console.log(search) // { food: \"rich\", price: \"$$\", ambiance: \"noisy\" } 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话： let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" }; let search = { food: \"rich\", ...defaults }; console.log(search) // { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" } 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法： class C { p = 12; m() { } } let c = new C(); let clone = { ...c }; clone.p; // ok clone.m(); // error! TypeScript编译器不允许展开泛型函数上的类型参数。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 23:52 "},"HandBook/Interfaces.html":{"url":"HandBook/Interfaces.html","title":"接口","keywords":"","body":"接口 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-13 23:07 "},"HandBook/Classes.html":{"url":"HandBook/Classes.html","title":"类","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Functions.html":{"url":"HandBook/Functions.html","title":"函数","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Generics.html":{"url":"HandBook/Generics.html","title":"泛型","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Enums.html":{"url":"HandBook/Enums.html","title":"枚举","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Type-Inference.html":{"url":"HandBook/Type-Inference.html","title":"类型推论","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Type-Compatibility.html":{"url":"HandBook/Type-Compatibility.html","title":"类型兼容性","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Advanced-Types.html":{"url":"HandBook/Advanced-Types.html","title":"高级类型","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 22:19 "},"HandBook/Symbols.html":{"url":"HandBook/Symbols.html","title":"Symbols","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Iterators-and-Generators.html":{"url":"HandBook/Iterators-and-Generators.html","title":"迭代器和生成器","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Modules.html":{"url":"HandBook/Modules.html","title":"模块","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Namespaces.html":{"url":"HandBook/Namespaces.html","title":"命名空间","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Namespaces-and-Modules.html":{"url":"HandBook/Namespaces-and-Modules.html","title":"命名空间和模块","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Module-Resolution.html":{"url":"HandBook/Module-Resolution.html","title":"模块解析","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Declaration-merging.html":{"url":"HandBook/Declaration-merging.html","title":"声明合并","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/JSX.html":{"url":"HandBook/JSX.html","title":"JSX","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Decorators.html":{"url":"HandBook/Decorators.html","title":"装饰器","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Triple-Slash-Directives.html":{"url":"HandBook/Triple-Slash-Directives.html","title":"三斜线指令","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Introduction.html":{"url":"Declaration-Files/Introduction.html","title":"介绍","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Library-Structures.html":{"url":"Declaration-Files/Library-Structures.html","title":"结构","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/By-Example.html":{"url":"Declaration-Files/By-Example.html","title":"举例","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Do's-and-Don'ts.html":{"url":"Declaration-Files/Do's-and-Don'ts.html","title":"规范","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Deep-Dive.html":{"url":"Declaration-Files/Deep-Dive.html","title":"深入","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Templates.html":{"url":"Declaration-Files/Templates.html","title":"模板","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Publishing.html":{"url":"Declaration-Files/Publishing.html","title":"发布","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Consumption.html":{"url":"Declaration-Files/Consumption.html","title":"使用","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/tsconfig.json.html":{"url":"Project-Configuration/tsconfig.json.html","title":"tsconfig.json","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Compiler-Options.html":{"url":"Project-Configuration/Compiler-Options.html","title":"编译选项","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Project-References.html":{"url":"Project-Configuration/Project-References.html","title":"项目引用","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Compiler-Options-in-MSBuild.html":{"url":"Project-Configuration/Compiler-Options-in-MSBuild.html","title":"MSBuild编译选项","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Integrating-with-Build-Tools.html":{"url":"Project-Configuration/Integrating-with-Build-Tools.html","title":"构建工具集成","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Nightly-Builts.html":{"url":"Project-Configuration/Nightly-Builts.html","title":"每日构建","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "}}