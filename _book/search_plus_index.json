{"./":{"url":"./","title":"Typescript 简介","keywords":"","body":"TypeScript 简介 TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码，可以运行在任何浏览器上。TypeScript添加了可选的静态类型系统、很多尚未正式发布的ECMAScript新特性（如装饰器 [1] ）支持 ECMAScript 6 标准。2012年10月，微软发布了首个公开版本的TypeScript，2013年6月19日，在经历了一个预览版之后微软正式发布了正式版TypeScript。 JavaScript 与 TypeScript 的区别 TypeScript 是 JavaScript 的超集，扩展了 JavaScript 的语法，因此现有的 JavaScript 代码可与 TypeScript 一起工作无需任何修改，TypeScript 通过类型注解提供编译时的静态类型检查。 TypeScript 可处理已有的 JavaScript 代码，并只对其中的 TypeScript 代码进行编译。 语言特性 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 以下功能是从 ECMA 2015 反向移植而来： 类 模块 lambda 函数的箭头语法 可选参数以及默认参数 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:58 "},"Tutorials/TypeScript-in-5-minutes.html":{"url":"Tutorials/TypeScript-in-5-minutes.html","title":"5分钟上手","keywords":"","body":"5分钟上手Typescript 让我们使用TypeScript来创建一个简单的Web应用。 1. 安装 npm install -g typescript 2. 构建你的第一个TypeScript文件 在编辑器，将下面的代码输入到greeter.ts文件 function greeter(person) { return \"Hello, \" + person; } let user = \"Jane User\"; console.log(greeter(user)) 然后在当前目录下运行 ts文件 tsc greeter.ts 执行命令之后会创建一个转义成ES5的greeter.js文件，它包含了和输入文件中相同的JavsScript代码。 接下来让我们看看TypeScript工具带来的高级功能。 给 person函数的参数添加: string类型注解，如下： function greeter(person: string) { return \"Hello, \" + person; } let user = \"Jane User\"; console.log(greeter(user)) 3. 类型注解 TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter函数接收一个字符串参数。 然后尝试把 greeter的调用改成传入一个数组： function greeter(person: string) { return \"Hello, \" + person; } let user = [0, 1, 2]; console.log(greeter(user)) 重新编译，你会看到产生了一个错误。 greeter.ts(6,21): error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'. 类似地，尝试删除greeter调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行。 4. 接口 让我们开发这个示例应用。这里我们使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。 interface Person { firstName: string; lastName: string; } function greeter(person: Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = { firstName: \"Jane\", lastName: \"User\" }; console.log(greeter(user)) 5. 类 最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。 让我们创建一个Student类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。 还要注意的是，在构造函数的参数上使用public等同于创建了同名的成员变量。 class Student { fullName: string; constructor(public firstName, public middleInitial, public lastName) { this.fullName = firstName + \" \" + middleInitial + \" \" + lastName; } } interface Person { firstName: string; lastName: string; } function greeter(person : Person) { return \"Hello, \" + person.firstName + \" \" + person.lastName; } let user = new Student(\"Jane\", \"M.\", \"User\"); console.log(greeter(user)) 重新运行tsc greeter.ts，你会看到生成的JavaScript代码和原先的一样。 TypeScript里的类只是JavaScript里常用的基于原型面向对象编程的简写。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Tutorials/Migrating-from-Javascript.html":{"url":"Tutorials/Migrating-from-Javascript.html","title":"从JavaScript迁移","keywords":"","body":"JavaScript 迁移 TypeScript不是存在于真空中。 它从JavaScript生态系统和大量现存的JavaScript而来。 将JavaScript代码转换成TypeScript虽乏味却不是难事。 接下来这篇教程将教你怎么做。 在开始转换TypeScript之前，我们假设你已经理解了足够多本手册里的内容。 1. 设置目录 如果你在写纯JavaScript，你大概是想直接运行这些JavaScript文件， 这些文件存在于 src，lib或dist目录里，它们可以按照预想运行。 若如此，那么你写的纯JavaScript文件将做为TypeScript的输入，你将要运行的是TypeScript的输出。 在从JS到TS的转换过程中，我们会分离输入文件以防TypeScript覆盖它们。 你也可以指定输出目录。 你可能还需要对JavaScript做一些中间处理，比如合并或经过Babel再次编译。 在这种情况下，我们假设你已经设置了这样的目录结构： projectRoot ├── src │ ├── file1.js │ └── file2.js ├── built └── tsconfig.json 如果你在src目录外还有tests文件夹，那么在src里可以有一个tsconfig.json文件，在tests里还可以有一个。 2. 编辑配置文件 TypeScript使用tsconfig.json文件管理工程配置，例如你想包含哪些文件和进行哪些检查。 让我们先创建一个简单的工程配置文件： { \"compilerOptions\": { \"outDir\": \"./built\", \"allowJs\": true, \"target\": \"es5\" }, \"include\": [ \"./src/**/*\" ] } 这里我们为TypeScript设置了一些东西: 读取所有可识别的src目录下的文件（通过include）。 接受JavaScript做为输入（通过allowJs）。 生成的所有文件放在built目录下（通过outDir）。 将JavaScript代码降级到低版本比如ECMAScript 5（通过target）。 现在，如果你在工程根目录下运行tsc，就可以在built目录下看到生成的文件。 built下的文件应该与src下的文件相同。 现在你的工程里的TypeScript已经可以工作了。 早期收益 现在你已经可以看到TypeScript带来的好处，它能帮助我们理解当前工程。 如果你打开像 VS Code或Visual Studio这样的编译器，你就能使用像自动补全这样的工具。 你还可以配置如下的选项来帮助查找BUG： noImplicitReturns 会防止你忘记在函数末尾返回值。 noFallthroughCasesInSwitch 会防止在switch代码块里的两个case之间忘记添加break语句。 TypeScript还能发现那些执行不到的代码和标签，你可以通过设置allowUnreachableCode和allowUnusedLabels选项来禁用。 3. 与构建工具进行集成 在你的构建管道中可能包含多个步骤。 比如为每个文件添加一些内容。 每种工具的使用方法都是不同的，我们会尽可能的包涵主流的工具。 1） Gulp 如果你在使用时髦的Gulp，我们已经有一篇关于使用Gulp结合TypeScript并与常见构建工具Browserify，Babelify和Uglify进行集成的教程。 请阅读这篇教程。 2）Webpack Webpack集成非常简单。 你可以使用 ts-loader，它是一个TypeScript的加载器，结合source-map-loader方便调试。 运行： $ npm install ts-loader source-map-loader -D 并将下面的选项合并到你的webpack.config.js文件里： module.exports = { entry: \"./src/index.ts\", output: { filename: \"./dist/bundle.js\", }, // Enable sourcemaps for debugging webpack's output. devtool: \"source-map\", resolve: { // Add '.ts' and '.tsx' as resolvable extensions. extensions: [\"\", \".webpack.js\", \".web.js\", \".ts\", \".tsx\", \".js\"] }, module: { loaders: [ // All files with a '.ts' or '.tsx' extension will be handled by 'ts-loader'. { test: /\\.tsx?$/, loader: \"ts-loader\" } ], preLoaders: [ // All output '.js' files will have any sourcemaps re-processed by 'source-map-loader'. { test: /\\.js$/, loader: \"source-map-loader\" } ] }, // Other options... }; 要注意的是ts-loader必须在其它处理.js文件的加载器之前运行。 4. 转换到TypeScript文件 到目前为止，你已经做好了使用TypeScript文件的准备。 第一步，将 .js文件重命名为.ts文件。 如果你使用了JSX，则重命名为 .tsx文件。 如果你不想让TypeScript将没有明确指定的类型默默地推断为 any类型，可以在修改文件之前启用noImplicitAny。 你可能会觉得这有些过度严格，但是长期收益很快就能显现出来。 在转换后将会看到错误信息。 重要的是我们要逐一的查看它们并决定如何处理。 通常这些都是真正的BUG，但有时必须要告诉TypeScript你要做的是什么。 1）由模块导入 你可能会看到一些类似Cannot find name 'require'.和Cannot find name 'define'.的错误。 遇到这种情况说明你在使用模块。 你仅需要告诉TypeScript它们是存在的： // For Node/CommonJS declare function require(path: string): any; 或者 // For RequireJS//AMD declare function define(...args: any[]): any; 最好是避免使用这些调用而改用TypeScript的导入语法 首先，你要使用TypeScript的module标记来启用一些模块系统，可用的选项有commonjs, amd, system,umd。 例如： var foo = require('foo') foo.doStuff(); 用TS语法改写 import foo = require('foo') foo.doSuff() 2）获取声明文件 js 转换成 ts 可能会遇到 cannot find module 'foo' 这样的错误，问题出在没有声明文件来描述你的代码库，幸运的是这非常简单，如果TS抱怨像是没有lodash包，那你只需要安装声明文件就可以 npm install -s @types/lodash 如果你没有使用 commonjs模块选项，那么就需要讲moduleResolution选项设置为node 之后，你就可以导入lodash了，并且会获得精确的自动补全功能。 3）由模块导出 通常来说，模块导出涉及到exports 或者 module.exports。TS 允许你是用顶级的导出语句，比如： 导出匿名函数 module.exports.feedPets = function(pets){ //... } TS改写： export function(pets){ // ... } 导出函数名: function foo(){ // ... } TS 改写： function foo(){ // ... } export = foo 4）过多或过少的参数 有时你会发现你在调用一个具有过多或者过少参数的函数。通常，这是一个BUG，单在某些情况下，你可以声明一个使用arguments对象而不需要写出所有的参数 function myCoolFunction() { if (arguments.length == 2 && !Array.isArray(arguments[1])) { var f = arguments[0]; var arr = arguments[1]; // ... } // ... } myCoolFunction(function(x) { console.log(x) }, [1, 2, 3, 4]); myCoolFunction(function(x) { console.log(x) }, 1, 2, 3, 4); 这种情况下，我们需要利用TypeScript的函数重载来告诉调用者 myCoolFunction函数的调用方式。 function myCoolFunction(f: (x: number)=> void, nums: number[]): void; function myCoolFunction(f: (x: number)=> void, ...nums: number[]): void; function myCoolFunction() { if(arguments.length == 2 && !Array.isArray(arguments[1])){ var f = arguments[0] var arr = arguments[1] // ... } // ... } 我们为 myCoolFunction 函数添加了两个重载签名。第一个检查myCoolFunction函数是否接受一个函数（它又接受一个number参数）和一个number数组。第二个同样接收了一个函数，并且剩余参数（...nums）来表示之后的其他所有参数必须是number类型 5）连续添加属性 有些人可能因为代码美观性而喜欢先创建一个对象然后立即添加属性 var option = {} option.color = 'red'; option.volum = 11 TS会提示你不能给color和volum赋值，因为先前指定option的类型为{}并不带有任何属性。如果你将声明变成对象字面量将不会产生错误。 var option = { color: 'red', volum : 11 } 你还可以定义option的类型并且添加类型断言到对象字面量上 interface Option {color: string, volum: number} let option = {} as Option option.color = 'red' option.volum = 11 你也可以把option指定成any类型，这是最简单的，也是受益最少的 any,Object,{}区别 any是最普通的类型但是允许你在上面做任何事情，也就是你可以在上面调用，构造，访问他的属性等等。但是当你使用any时，也就意味着你将失去大多数 TS 听歌的错误检查和编译器支持。 如果你还是决定使用Object和{}，虽说他们基本一样，但是从技术层面说，{}在一些深奥的情况里比Object更普通 6）启用严格检查 TypeScript提供了一些检查来保证安全以及帮助分析你的程序。 当你将代码转换为了TypeScript后，你可以启用这些检查来帮助你获得高度安全性。 （1）没有隐式的any 在某些情况下TypeScript没法确定某些值的类型。 那么TypeScript会使用 any类型代替。 这对代码转换来讲是不错，但是使用 any意味着失去了类型安全保障，并且你得不到工具的支持。 你可以使用 noImplicitAny选项，让TypeScript标记出发生这种情况的地方，并给出一个错误。 （2）严格的 null 和 undefined 替换 默认地，TypeScript把null和undefined当做属于任何类型。 这就是说，声明为 number类型的值可以为null和undefined。 因为在JavaScript和TypeScript里， null和undefined经常会导致BUG的产生，所以TypeScript包含了strictNullChecks选项来帮助我们减少对这种情况的担忧。 当启用了strictNullChecks，null和undefined获得了它们自己各自的类型null和undefined。 当任何值 可能为null，你可以使用联合类型。 比如，某值可能为 number或null，你可以声明它的类型为number | null。 假设有一个值TypeScript认为可以为null或undefined，但是你更清楚它的类型，你可以使用!后缀。 declare var foo: string[] | null; foo.length; // error - 'foo' is possibly 'null' foo!.length; // okay - 'foo!' just has type 'string[]' 要当心，当你使用strictNullChecks，你的依赖也需要相应地启用strictNullChecks。 （3）this 没有隐式的 any 当你在类的外部使用this关键字时，它会默认获得any类型。 比如，假设有一个 Point类，并且我们要添加一个函数做为它的方法： class Point { constructor(public x, public y){ } getDistance(p: Point){ let dx = p.x - this.x; let dy = p.y - this.y; return Msth.sqrt(dx**2 + dy**2) } } // ... // 重开断言 interface Point { distanceFromOrigin(point: Point): number; } Point.prototype.distanceFromOrigin = function(point: Point){ return this.getDistance({x: 0, y: 0}) } 这就产生了我们上面提到的错误 - 如果我们错误地拼写了getDistance并不会得到一个错误。 正因此，TypeScript有 noImplicitThis选项。 当设置了它，TypeScript会产生一个错误当没有明确指定类型（或通过类型推断）的 this被使用时。 解决的方法是在接口或函数上使用指定了类型的 this参数： 下面是原型链改写 Point.prototype.distanceFromOrigin = function(this: Point, point: Point){ return this.getDistance({x: 0, y: 0}); } Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-11 21:29 "},"HandBook/Basic-Types.html":{"url":"HandBook/Basic-Types.html","title":"基础类型","keywords":"","body":"基础类型 1. 布尔值 boolean，可以定义为true/false let isDone: boolean = false 2. 数值 number，所有的数字都是浮点数，支持十进制，十六进制，二进制和八进制 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; 3. 字符串 string，可以使用双引号（\"\"）、单引号（''）和反引号（`` ）表示 let name: string = 'bob'; let sex: string = \"male\"; let sentence: string = `hello, my name is ${name}`; 4. 数组 有两种方法可以定义数组 在元素类型后面接上[]，表示由此类型元素组成一个数组 let list: number[] = [1, 2, 3]; 使用数组泛型，Array let list: Array = [1, 2, 3]; 5. 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同，比如你可以定义一对值分别为string和number类型的元组 let x: [string, number]; x = ['hello', 10]; // ok x = [10, 'hello']; // error 当访问一个一直索引的元素，会得到正确的类型 console.log(x[0].substr(1)); // ello console.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个跨界的元素，会使用联合类型替代 x[3] = 'world';// OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 6. 枚举 enum类型是对JavaScript标准数据类型的一个补充 enum Color {Red, Green, Yellow} let c: Color = Color.Green 默认情况下，从0开始为元素编号，你也可以手动指定成员的数值。例如，我们将上面的例子改成从1开始编号： enum Color {Red=1, Green, Yellow} let c: Color = Color.Green 也可以全部手动赋值 enum Color {Red=1, Green=2, Yellow=4} let colorName: string = Color[2] console.log(colorName) // 显示'Green'因为上面代码里它的值是2 7. Any any，有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这些值可能来子推燕动态的内容，比如用户输入或者第三方代码库。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让他们通过编译阶段的检查，那我们就可使用any类型来标记这些变量： let notSure: any = 4; notSure = 'hello'; notSure = true; 在对现有代码进行改写的时候，any类型是十分有用的。他允许你在变异时可选择地包含或移除类型检查。你可能认为Object有相似的作用，就想他在其他语言中的那样。但是Object类型的变量只是允许你给他赋任意值，但是却不能够在他上面调用任何方法，几遍他真的有这些方法： let notSure: any = 4; notSure.ifItExists(); // okay, ifItExists might exist at runtime notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check) let prettySure: Object = 4; prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object' 当你只知道一部分数据类型时，any类型也是有用的。比如，你有一个数组，他包含了不同的类型的数据： let list: any[] = [1, 'hello', true]; list[1] = 100; 8. Void void，某种程度上来说void类型和any类型相反，他标书没有任何类型。当一个函数没有返回之时，你通常会见到其返回值类型为void： function warnUser(): void{ console.log('This is my warning message'); } 声明一个void类型的变量没有什么大用，因为你指能赋予它undefined和null let unusable: void = undefined; 9. Null 和 Undefined null的类型就是null undefined的类型就是undefined 和void相似，他们本身的类型用处不是很大： // 我们不能给这些变量赋太多的值 let u: undefined = undefined; let n: null = null; 默认情况下，null和undefined是所有类型的子类型，也就是说你可以把null和undefined赋值给number类型的变量 然而，当你制定了--strictNullChecks标记时，null和undefined只能赋值给void和他们各自。这能避免很多常见的问题，允许在某处你想传入一个string或null或undefined，你可以使用联合类型string | null | undefined。 注意： 我们应该尽可能的使用 --strictNullChecks 10. Never never类型表示哪些用不存在值得类型，例如：never类型是那些总会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；变量也可能是never类型，当他们被用不为真的类型保护所约束时。 never类型是任意类型的子类型，也可以赋值给任意类型；然而，没有类型是never的子类型或可以赋值给never类型，（除了never本身之外）。即使any也不可以赋值给never。 下面是一些返回never类型的函数： // 返回 never类型的函数必须存在无法达到的终点，抛出异常 function error(message: string): never{ throw new Error(message); } // 推断类型的返回值类型为never, 返回一个错误 function fail(){ return error('something failed'); } // 返回never函数必须存在无法到达的终点 function infiniteLoop(): never { while (true){ // ... } } 11. Object object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的 API，例如： declare function create(o: object | null): void; create({prop: 0}); // ok create(null); // ok create(42); // Error create('string'); // Error create(false); // Error create(undefined); // Error 12. 类型断言 有些时候，你会比TypeScript更了解某个值的详细信息，通常这会发生在你清楚地知道一个实体具有比他现有类型更确切的类型。 通过类型断言这种方式告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言中的类型转换，但是不进行特殊的数据检查和结构。他没有运行时的影响，只在编译阶段起作用， TypeScript 会假设你已经进行了必须的检查。 类型断言有两种形式： “尖括号”语法： let someValue: any = 'this is a string'; let strLength: number = (someValue).length; as语法 let someValue: any = 'this is a string'; let strLength: number = (someValue as string).length 两种形式是等价的。至于使用哪种写法全凭个人喜好；然而，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 23:52 "},"HandBook/Variable-Declarations.html":{"url":"HandBook/Variable-Declarations.html","title":"变量声明","keywords":"","body":"变量声明 1. var 一直以来我们都是通过var关键字定义JavaScript变量： var num = 10; 我们也可以在函数内部定义变量： function f() { var message = \"Hello, world!\"; return message; } 并且我们也可以在其它函数内部访问相同的变量。 function f() { var a = 10; return function g() { var b = a + 1; return b; } } var g = f(); g(); // returns 11; 上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。 function f() { var a = 1; a = 2; var b = g(); a = 3; return b; function g() { return a; } } f(); // returns 2 作用域规则 对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子： function f(shouldInitialize: boolean) { if (shouldInitialize) { var x = 10; } return x; } f(true); // returns '10' f(false); // returns 'undefined' 变量 x是定义在if语句里面，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为 var作用域或函数作用域。 函数参数也使用函数作用域。 这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错： function sumMatrix(matrix: number[][]) { var sum = 0; for (var i = 0; i 这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。 捕获变量怪异之处 快速的猜一下下面的代码会返回什么： for (var i = 0; i 介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。 运行结果： 10 10 10 10 10 很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样： 0 1 2 3 4 我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为5。 所以当函数被调用的时候，它会打印出 5！ 一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值： for (var i = 0; i 参数 i会覆盖for循环里的i，但是因为我们起了同样的名字，所以我们不用怎么改for循环体里的代码。 2. let let与var的写法一致。 let hello = \"Hello!\"; 块作用域 当用let声明一个变量，它使用的是词法作用域或块作用域。 块作用域变量在包含它们的块或for循环之外是不能访问的。 function f(input: boolean) { let a = 100; if (input) { // Still okay to reference 'a' let b = a + 1; return b; } // Error: 'b' doesn't exist here return b; } 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。 在catch语句里声明的变量也具有同样的作用域规则。 try { throw \"oh no!\"; } catch (e) { console.log(\"Oh well.\"); } // Error: 'e' doesn't exist here console.log(e); 拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。 a++; // illegal to use 'a' before it's declared; let a; 重定义和屏蔽 我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。 function f(x) { var x; var x; if (true) { var x; } } let声明就不会这么宽松: let x = 10; let x = 20; // 错误，不能在1个作用域里多次声明`x` 同样let声明和var声明，以及参数名重复时，也会给出错误 function f(x) { let x = 100; // error: interferes with parameter declaration } function g() { let x = 100; var x = 100; // error: can't have both declarations of 'x' } 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。 function sumMatrix(matrix: number[][]) { let sum = 0; for (let i = 0; i 这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。 通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它。 块级作用域变量的获取 用var声明的变量时，就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。 function theCityThatAlwaysSleeps() { let getCity; if (true) { let city = \"Seattle\"; getCity = function() { return city; } } return getCity(); } 因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。 for (let i = 0; i 会输出与预料一致的结果： 0 1 2 3 4 3. const const 声明是声明变量的另一种方式。 const numLivesForCat = 9; 它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。 这很好理解，它们引用的值是不可变的。 const numLivesForCat = 9; const kitty = { name: \"Aurora\", numLives: numLivesForCat, } // Error kitty = { name: \"Danielle\", numLives: numLivesForCat }; // all \"okay\" kitty.name = \"Rory\"; kitty.name = \"Kitty\"; kitty.name = \"Cat\"; kitty.numLives--; 除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 4. let VS const 使用最小特权原则，所有变量除了你计划去修改的都应该使用const，使用 const也可以让我们更容易的推测数据的流动。 5. 解构 解构数组 最简单的解构莫过于数组的解构赋值了： let input = [1, 2]; let [first, second] = input; console.log(first); // 1 console.log(second); // 2 解构作用于已声明的变量会更好： // 交换变量 [first, second] = [second, first]; 作用于函数参数： function f([first, second]: [number, number]) { console.log(first); console.log(second); } f(input); 你可以在数组里使用...语法创建剩余变量： let [first, ...rest] = [1, 2, 3, 4]; console.log(first); // 1 console.log(rest); // [ 2, 3, 4 ] 当然，由于是JavaScript, 你可以忽略你不关心的尾随元素： let [first] = [1, 2, 3, 4]; console.log(first); // 1 或其它元素： let [, second, , fourth] = [1, 2, 3, 4]; 结构对象 let o = { a: \"foo\", b: 12, c: \"bar\" }; let { a, b } = o; 这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。 就像数组解构，你可以用没有声明的赋值： ({ a, b } = { a: \"baz\", b: 101 }); a // \"baz\" b // 101 注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。 你可以在对象里使用...语法创建剩余变量： let { a, ...passthrough } = o; let total = passthrough.b + passthrough.c.length; total // 15 属性重命名 你也可以给属性以不同的名字： let { a: newName1, b: newName2 } = o; 令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。 let {a, b}: {a: string, b: number} = o; 默认值 默认值可以让你在属性为 undefined 时使用缺省值： function keepWholeObject(wholeObject: { a: string, b?: number }) { let { a, b = 1001 } = wholeObject; } 现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。 函数声明 解构也能用于函数声明。 看以下简单的情况： type C = { a: string, b?: number } function f({ a, b }: C): void { // ... } 但是，通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式。 function f({ a=\"\", b=0 } = {}): void { // ... } f(); 其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性： function f({ a, b = 0 } = { a: \"\" }): void { // ... } f({ a: \"yes\" }); // ok, default b = 0 f(); // ok, default to {a: \"\"}, which then defaults b = 0 f({}); // error, 参数'a' 是必须赋值的 展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如： let first = [1, 2]; let second = [3, 4]; let bothPlus = [0, ...first, ...second, 5]; console.log(bothPlus) // [0, 1, 2, 3, 4, 5] 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。 还可以展开对象： let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" }; let search = { ...defaults, food: \"rich\" }; console.log(search) // { food: \"rich\", price: \"$$\", ambiance: \"noisy\" } 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话： let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" }; let search = { food: \"rich\", ...defaults }; console.log(search) // { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" } 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法： class C { p = 12; m() { } } let c = new C(); let clone = { ...c }; clone.p; // ok clone.m(); // error! TypeScript编译器不允许展开泛型函数上的类型参数。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 23:52 "},"HandBook/Interfaces.html":{"url":"HandBook/Interfaces.html","title":"接口","keywords":"","body":"接口 1. 介绍 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 2. 接口初探 下面通过一个简单示例来观察接口是如何工作的： function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label); } let myObj = { size: 10, label: \"Size 10 Object\" }; printLabel(myObj); 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string： interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj); LabelledValue接口就好比一个名字，用来描述上面例子里的要求。它代表了有一个label属性且类型为string的对象。 还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 3. 可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。 下面是应用了“option bags”的例子： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): {color: string; area: number} { let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); 可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { let newSquare = {color: \"white\", area: 100}; if (config.clor) { // Error: Property 'clor' does not exist on type 'SquareConfig' newSquare.color = config.clor; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); 4. 只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性: interface Point { readonly x: number; readonly y: number; } 你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。 let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript具有ReadonlyArray类型，它与Array相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写： a = ro as number[]; 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 5. 额外的属性检查 我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。 然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { // ... } let mySquare = createSquare({ colour: \"red\", width: 100 }); 注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。 你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。 然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。 // error: 'colour' not expected in type 'SquareConfig' let mySquare = createSquare({ colour: \"red\", width: 100 }); 绕开这些检查非常简单。 最简便的方法是使用类型断言： let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它： interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。 6. 函数类型 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } 这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。 let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result > -1; } 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子： let mySearch: SearchFunc; mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result > -1; } 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，返回的类型也必须的定义匹配，不想返回值指定类型，TypeScript同样会推断出返回值类型。如此，上面的函数可以写成下面这种形式： let mySearch: SearchFunc; mySearch = function(src, sub) { let result = src.search(sub); return result > -1; } 7. 可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[1]或obj[\"name\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子： interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。 TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。 class Animal { name: string; } class Dog extends Animal { breed: string; } // 错误：使用数值型的字符串索引，有时会得到完全不同的Animal! interface NotOkay { [x: number]: Animal; [x: string]: Dog; } 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配 } 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值： interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"]; myArray[2] = \"Mallory\"; // error! 你不能设置myArray[2]，因为索引签名是只读的。 8. 类类型 1）实现接口 与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 interface ClockInterface { currentTime: Date; } class Clock implements ClockInterface { currentTime: Date; constructor(h: number, m: number) { } } 你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样： interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 2）类静态部分与实力部分的区别 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误： interface ClockConstructor { new (hour: number, minute: number); } class Clock implements ClockConstructor { currentTime: Date; constructor(h: number, m: number) { } } 这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。 因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。 interface ClockConstructor { new (hour: number, minute: number): ClockInterface; } interface ClockInterface { tick(); } function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute); } class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"beep beep\"); } } class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"tick tock\"); } } let digital = createClock(DigitalClock, 12, 17); let analog = createClock(AnalogClock, 7, 32); 3）继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 interface Shape { color: string; } interface Square extends Shape { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; 一个接口也可以继承多个接口，创建出多个接口的合成接口。 interface Shape { color: string; } interface PenStroke { penWidth: number; } interface Square extends Shape, PenStroke { sideLength: number; } let square = {}; square.color = \"blue\"; square.sideLength = 10; square.penWidth = 5.0; 9. 混合接口 有时你会希望一个对象可以同时具有上面提到的多种类型。 一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。 interface Counter { (start: number): string; interval: number; reset(): void; } function getCounter(): Counter { let counter = function (start: number) { }; counter.interval = 123; counter.reset = function () { }; return counter; } let c = getCounter(); c(10); c.reset(); c.interval = 5.0; 在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。 10. 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例： class Control { private state: any; } interface SelectableControl extends Control { select(): void; } class Button extends Control implements SelectableControl { select() { } } class TextBox extends Control { select() { } } // 错误：“Image”类型缺少“state”属性。 class Image implements SelectableControl { select() { } } class Location { } 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。 Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-13 23:10 "},"HandBook/Classes.html":{"url":"HandBook/Classes.html","title":"类","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Functions.html":{"url":"HandBook/Functions.html","title":"函数","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Generics.html":{"url":"HandBook/Generics.html","title":"泛型","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Enums.html":{"url":"HandBook/Enums.html","title":"枚举","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Type-Inference.html":{"url":"HandBook/Type-Inference.html","title":"类型推论","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Type-Compatibility.html":{"url":"HandBook/Type-Compatibility.html","title":"类型兼容性","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Advanced-Types.html":{"url":"HandBook/Advanced-Types.html","title":"高级类型","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-12 22:19 "},"HandBook/Symbols.html":{"url":"HandBook/Symbols.html","title":"Symbols","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Iterators-and-Generators.html":{"url":"HandBook/Iterators-and-Generators.html","title":"迭代器和生成器","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Modules.html":{"url":"HandBook/Modules.html","title":"模块","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Namespaces.html":{"url":"HandBook/Namespaces.html","title":"命名空间","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Namespaces-and-Modules.html":{"url":"HandBook/Namespaces-and-Modules.html","title":"命名空间和模块","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Module-Resolution.html":{"url":"HandBook/Module-Resolution.html","title":"模块解析","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Declaration-merging.html":{"url":"HandBook/Declaration-merging.html","title":"声明合并","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/JSX.html":{"url":"HandBook/JSX.html","title":"JSX","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Decorators.html":{"url":"HandBook/Decorators.html","title":"装饰器","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"HandBook/Triple-Slash-Directives.html":{"url":"HandBook/Triple-Slash-Directives.html","title":"三斜线指令","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Introduction.html":{"url":"Declaration-Files/Introduction.html","title":"介绍","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Library-Structures.html":{"url":"Declaration-Files/Library-Structures.html","title":"结构","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/By-Example.html":{"url":"Declaration-Files/By-Example.html","title":"举例","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Do's-and-Don'ts.html":{"url":"Declaration-Files/Do's-and-Don'ts.html","title":"规范","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Deep-Dive.html":{"url":"Declaration-Files/Deep-Dive.html","title":"深入","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Templates.html":{"url":"Declaration-Files/Templates.html","title":"模板","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Publishing.html":{"url":"Declaration-Files/Publishing.html","title":"发布","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Declaration-Files/Consumption.html":{"url":"Declaration-Files/Consumption.html","title":"使用","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/tsconfig.json.html":{"url":"Project-Configuration/tsconfig.json.html","title":"tsconfig.json","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Compiler-Options.html":{"url":"Project-Configuration/Compiler-Options.html","title":"编译选项","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Project-References.html":{"url":"Project-Configuration/Project-References.html","title":"项目引用","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Compiler-Options-in-MSBuild.html":{"url":"Project-Configuration/Compiler-Options-in-MSBuild.html","title":"MSBuild编译选项","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Integrating-with-Build-Tools.html":{"url":"Project-Configuration/Integrating-with-Build-Tools.html","title":"构建工具集成","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "},"Project-Configuration/Nightly-Builts.html":{"url":"Project-Configuration/Nightly-Builts.html","title":"每日构建","keywords":"","body":"Copyright © lucky__star 2020 all right reserved，powered by Gitbook本书发布时间： 2020-03-07 21:25 "}}